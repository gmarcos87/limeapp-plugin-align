'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _alignApi = require('./alignApi');

var _Observable = require('rxjs/Observable');

require('rxjs/add/observable/from');

require('rxjs/add/observable/of');

require('rxjs/add/observable/interval');

require('rxjs/add/operator/takeUntil');

require('rxjs/add/operator/mergeMap');

require('rxjs/add/operator/switchMap');

require('rxjs/add/operator/mapTo');

require('rxjs/add/operator/map');

require('rxjs/add/operator/catch');

var _alignConstants = require('./alignConstants');

// LOAD INTERFACES -> Dispatch success and stations loads
var ifaceLoad = function ifaceLoad(action$, _ref, _ref2) {
  var getState = _ref.getState;
  var wsAPI = _ref2.wsAPI;
  return action$.ofType.apply(action$, [_alignConstants.IFACES_LOAD]).mergeMap(function (action) {
    return (0, _alignApi.getInterfaces)(wsAPI, getState().meta.sid);
  }).mergeMap(function (payload) {
    return _Observable.Observable.from([{ type: _alignConstants.IFACES_LOAD_SUCCESS, payload: payload }, { type: _alignConstants.STATIONS_LOAD }]);
  });
};

// LOAD ALL STATIONS -> Dispatch success and Init Align
var allStationsLoad = function allStationsLoad(action$, _ref3, _ref4) {
  var getState = _ref3.getState;
  var wsAPI = _ref4.wsAPI;
  return action$.ofType(_alignConstants.STATIONS_LOAD).mergeMap(function () {
    return (0, _alignApi.getStations)(wsAPI, getState().meta.sid);
  }).map(function (payload) {
    return { type: _alignConstants.STATIONS_LOAD_SUCCESS, payload: payload };
  }).catch(function (error) {
    return _Observable.Observable.of({
      type: 'NOTIFICATION',
      payload: { msg: 'Not stations in interfaces' },
      error: true
    });
  });
};

// CHANGE INTEFACE -> DIspatch get station by interface and select best signal
var ifaceChange = function ifaceChange(action$, _ref5, _ref6) {
  var getState = _ref5.getState;
  var wsAPI = _ref6.wsAPI;
  return action$.ofType(_alignConstants.IFACE_CHANGE).mergeMap(function (action) {
    return (0, _alignApi.getIfaceStation)(wsAPI, getState().meta.sid, action.payload.iface);
  }).map(function (payload) {
    return payload.nodes;
  }).map(function (payload) {
    return { type: _alignConstants.STATIONS_LOAD_SUCCESS, payload: payload };
  }).catch(function (error) {
    return _Observable.Observable.of({
      type: 'NOTIFICATION',
      payload: { msg: 'Not stations in interface' },
      error: true
    });
  });
};

// INIT ALIGN -> Select best node, interface and start timer
var initAlign = function initAlign(action$, _ref7) {
  var getState = _ref7.getState;
  return action$.ofType(_alignConstants.STATIONS_LOAD_SUCCESS).map(function (action) {
    return action.payload;
  }).map(function (payload) {
    if (typeof getState().rx.data.most_active !== 'undefined') {
      return payload.filter(function (x) {
        return x.mac === getState().rx.data.most_active.mac;
      })[0];
    }
    return payload.sort(function (x, y) {
      return x.signal + y.signal;
    })[0];
  }).mergeMap(function (res) {
    return _Observable.Observable.from([{ type: _alignConstants.STATION_SET, payload: res }, { type: _alignConstants.IFACE_SET, payload: res.iface }, { type: _alignConstants.TIMER_START }]);
  });
};

// GET_SIGNAL -> Update current signal and nodes
var getSignal = function getSignal(action$, _ref8, _ref9) {
  var getState = _ref8.getState;
  var wsAPI = _ref9.wsAPI;
  return action$.ofType(_alignConstants.SIGNAL_GET).switchMap(function () {
    return (0, _alignApi.getStationSignal)(wsAPI, getState().meta.sid, getState().align.currentReading);
  }).map(function (signal) {
    return { type: _alignConstants.SIGNAL_GET_SUCCESS, payload: signal };
  });
};

// TIMER MANAGER
var runTimer = function runTimer(action$, _ref10) {
  var getState = _ref10.getState;
  return action$.ofType(_alignConstants.TIMER_START).mergeMap(function (actions) {
    return _Observable.Observable.interval(getState().meta.interval).takeUntil(action$.ofType(_alignConstants.TIMER_STOP)).map(function () {
      return { type: _alignConstants.SIGNAL_GET };
    });
  });
};

exports.default = { ifaceLoad: ifaceLoad, allStationsLoad: allStationsLoad, ifaceChange: ifaceChange, initAlign: initAlign, getSignal: getSignal, runTimer: runTimer };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hbGlnbkVwaWNzLmpzIl0sIm5hbWVzIjpbImlmYWNlTG9hZCIsImFjdGlvbiQiLCJnZXRTdGF0ZSIsIndzQVBJIiwib2ZUeXBlIiwibWVyZ2VNYXAiLCJhY3Rpb24iLCJtZXRhIiwic2lkIiwicGF5bG9hZCIsImZyb20iLCJ0eXBlIiwiYWxsU3RhdGlvbnNMb2FkIiwibWFwIiwiY2F0Y2giLCJvZiIsIm1zZyIsImVycm9yIiwiaWZhY2VDaGFuZ2UiLCJpZmFjZSIsIm5vZGVzIiwiaW5pdEFsaWduIiwicngiLCJkYXRhIiwibW9zdF9hY3RpdmUiLCJmaWx0ZXIiLCJ4IiwibWFjIiwic29ydCIsInkiLCJzaWduYWwiLCJyZXMiLCJnZXRTaWduYWwiLCJzd2l0Y2hNYXAiLCJhbGlnbiIsImN1cnJlbnRSZWFkaW5nIiwicnVuVGltZXIiLCJhY3Rpb25zIiwiaW50ZXJ2YWwiLCJ0YWtlVW50aWwiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQWdCQTtBQUNBLElBQU1BLFlBQVksU0FBWkEsU0FBWSxDQUFFQyxPQUFGO0FBQUEsTUFBYUMsUUFBYixRQUFhQSxRQUFiO0FBQUEsTUFBMkJDLEtBQTNCLFNBQTJCQSxLQUEzQjtBQUFBLFNBQ2hCRixRQUFRRyxNQUFSLGdCQUFrQiw2QkFBbEIsRUFDR0MsUUFESCxDQUNZLFVBQUNDLE1BQUQ7QUFBQSxXQUFZLDZCQUFjSCxLQUFkLEVBQXFCRCxXQUFXSyxJQUFYLENBQWdCQyxHQUFyQyxDQUFaO0FBQUEsR0FEWixFQUVLSCxRQUZMLENBRWMsVUFBQ0ksT0FBRDtBQUFBLFdBQWEsdUJBQVdDLElBQVgsQ0FBZ0IsQ0FDcEMsRUFBRUMseUNBQUYsRUFBNkJGLGdCQUE3QixFQURvQyxFQUVwQyxFQUFFRSxtQ0FBRixFQUZvQyxDQUFoQixDQUFiO0FBQUEsR0FGZCxDQURnQjtBQUFBLENBQWxC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QUFBLFNBQ2hCRixRQUFRRyxNQUFSLDZCQUNHNkIsU0FESCxDQUNhO0FBQUEsV0FBTSxnQ0FBaUI5QixLQUFqQixFQUF3QkQsV0FBV0ssSUFBWCxDQUFnQkMsR0FBeEMsRUFBNkNOLFdBQVdnQyxLQUFYLENBQWlCQyxjQUE5RCxDQUFOO0FBQUEsR0FEYixFQUVLdEIsR0FGTCxDQUVVO0FBQUEsV0FBVyxFQUFFRix3Q0FBRixFQUE0QkYsU0FBU3FCLE1BQXJDLEVBQVg7QUFBQSxHQUZWLENBRGdCO0FBQUEsQ0FBbEI7O0FBS0E7QUFDQSxJQUFNTSxXQUFXLFNBQVhBLFFBQVcsQ0FBRW5DLE9BQUY7QUFBQSxNQUFhQyxRQUFiLFVBQWFBLFFBQWI7QUFBQSxTQUNmRCxRQUFRRyxNQUFSLDhCQUNHQyxRQURILENBQ1ksVUFBQ2dDLE9BQUQsRUFBYTtBQUNyQixXQUFPLHVCQUFXQyxRQUFYLENBQW9CcEMsV0FBV0ssSUFBWCxDQUFnQitCLFFBQXBDLEVBQ0pDLFNBREksQ0FDTXRDLFFBQVFHLE1BQVIsNEJBRE4sRUFFSlMsR0FGSSxDQUVBO0FBQUEsYUFBTyxFQUFFRixnQ0FBRixFQUFQO0FBQUEsS0FGQSxDQUFQO0FBR0QsR0FMSCxDQURlO0FBQUEsQ0FBakI7O2tCQVFlLEVBQUVYLG9CQUFGLEVBQWFZLGdDQUFiLEVBQThCTSx3QkFBOUIsRUFBMkNHLG9CQUEzQyxFQUFzRFcsb0JBQXRELEVBQWlFSSxrQkFBakUsRSIsImZpbGUiOiJhbGlnbkVwaWNzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0SW50ZXJmYWNlcywgZ2V0U3RhdGlvbnMsIGdldElmYWNlU3RhdGlvbiwgZ2V0U3RhdGlvblNpZ25hbH0gZnJvbSAnLi9hbGlnbkFwaSc7XG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb20nO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL29mJztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9pbnRlcnZhbCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3Rha2VVbnRpbCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL21lcmdlTWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvbWFwVG8nO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9jYXRjaCc7XG5cbmltcG9ydCB7XG4gIElGQUNFU19MT0FELFxuICBJRkFDRVNfTE9BRF9TVUNDRVNTLFxuICBJRkFDRV9TRVQsXG4gIElGQUNFX0NIQU5HRSxcbiAgU1RBVElPTlNfTE9BRCxcbiAgU1RBVElPTlNfTE9BRF9TVUNDRVNTLFxuICBTVEFUSU9OX1NFVCxcbiAgVElNRVJfU1RBUlQsXG4gIFRJTUVSX1NUT1AsXG4gIFNJR05BTF9HRVQsXG4gIFNJR05BTF9HRVRfU1VDQ0VTUyxcbiAgSU5JVF9BTElHTlxufSBmcm9tICcuL2FsaWduQ29uc3RhbnRzJztcblxuXG4vLyBMT0FEIElOVEVSRkFDRVMgLT4gRGlzcGF0Y2ggc3VjY2VzcyBhbmQgc3RhdGlvbnMgbG9hZHNcbmNvbnN0IGlmYWNlTG9hZCA9ICggYWN0aW9uJCwgeyBnZXRTdGF0ZSB9LCB7IHdzQVBJIH0gKSA9PlxuICBhY3Rpb24kLm9mVHlwZSguLi5bSUZBQ0VTX0xPQURdKVxuICAgIC5tZXJnZU1hcCgoYWN0aW9uKSA9PiBnZXRJbnRlcmZhY2VzKHdzQVBJLCBnZXRTdGF0ZSgpLm1ldGEuc2lkKSlcbiAgICAgIC5tZXJnZU1hcCgocGF5bG9hZCkgPT4gT2JzZXJ2YWJsZS5mcm9tKFtcbiAgICAgICAgKHsgdHlwZTogSUZBQ0VTX0xPQURfU1VDQ0VTUywgcGF5bG9hZCB9KSxcbiAgICAgICAgKHsgdHlwZTogU1RBVElPTlNfTE9BRCB9KVxuICAgICAgXSkpO1xuXG5cbi8vIExPQUQgQUxMIFNUQVRJT05TIC0+IERpc3BhdGNoIHN1Y2Nlc3MgYW5kIEluaXQgQWxpZ25cbmNvbnN0IGFsbFN0YXRpb25zTG9hZCA9IChhY3Rpb24kLCB7IGdldFN0YXRlIH0sIHsgd3NBUEkgfSAgKSA9PlxuICBhY3Rpb24kLm9mVHlwZShTVEFUSU9OU19MT0FEKVxuICAgIC5tZXJnZU1hcCgoKSA9PiBnZXRTdGF0aW9ucyh3c0FQSSwgZ2V0U3RhdGUoKS5tZXRhLnNpZCkpXG4gICAgICAubWFwKChwYXlsb2FkKSA9PiAoeyB0eXBlOiBTVEFUSU9OU19MT0FEX1NVQ0NFU1MsIHBheWxvYWQgfSkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4gT2JzZXJ2YWJsZS5vZih7XG4gICAgICAgIHR5cGU6ICdOT1RJRklDQVRJT04nLFxuICAgICAgICBwYXlsb2FkOiB7IG1zZzogJ05vdCBzdGF0aW9ucyBpbiBpbnRlcmZhY2VzJyB9LFxuICAgICAgICBlcnJvcjogdHJ1ZVxuICAgICAgfSkpO1xuXG4vLyBDSEFOR0UgSU5URUZBQ0UgLT4gRElzcGF0Y2ggZ2V0IHN0YXRpb24gYnkgaW50ZXJmYWNlIGFuZCBzZWxlY3QgYmVzdCBzaWduYWxcbmNvbnN0IGlmYWNlQ2hhbmdlID0gKGFjdGlvbiQsIHsgZ2V0U3RhdGUgfSwgeyB3c0FQSSB9ICkgPT5cbiAgYWN0aW9uJC5vZlR5cGUoSUZBQ0VfQ0hBTkdFKVxuICAgIC5tZXJnZU1hcCgoYWN0aW9uKSA9PiBnZXRJZmFjZVN0YXRpb24od3NBUEksIGdldFN0YXRlKCkubWV0YS5zaWQsIGFjdGlvbi5wYXlsb2FkLmlmYWNlKSlcbiAgICAubWFwKCBwYXlsb2FkID0+IHBheWxvYWQubm9kZXMpXG4gICAgLm1hcCgocGF5bG9hZCkgPT4gKHsgdHlwZTogU1RBVElPTlNfTE9BRF9TVUNDRVNTLCBwYXlsb2FkIH0pKVxuICAgIC5jYXRjaChlcnJvciA9PiBPYnNlcnZhYmxlLm9mKHtcbiAgICAgIHR5cGU6ICdOT1RJRklDQVRJT04nLFxuICAgICAgcGF5bG9hZDogeyBtc2c6ICdOb3Qgc3RhdGlvbnMgaW4gaW50ZXJmYWNlJyB9LFxuICAgICAgZXJyb3I6IHRydWVcbiAgICB9KSk7XG5cbi8vIElOSVQgQUxJR04gLT4gU2VsZWN0IGJlc3Qgbm9kZSwgaW50ZXJmYWNlIGFuZCBzdGFydCB0aW1lclxuY29uc3QgaW5pdEFsaWduID0gKGFjdGlvbiQsIHsgZ2V0U3RhdGUgfSApID0+XG4gIGFjdGlvbiQub2ZUeXBlKFNUQVRJT05TX0xPQURfU1VDQ0VTUylcbiAgICAubWFwKGFjdGlvbiA9PiBhY3Rpb24ucGF5bG9hZClcbiAgICAubWFwKHBheWxvYWQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBnZXRTdGF0ZSgpLnJ4LmRhdGEubW9zdF9hY3RpdmUgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQuZmlsdGVyKHggPT4geC5tYWMgPT09IGdldFN0YXRlKCkucnguZGF0YS5tb3N0X2FjdGl2ZS5tYWMpWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBheWxvYWQuc29ydCgoeCwgeSkgPT4geC5zaWduYWwgKyB5LnNpZ25hbClbMF07XG4gICAgfSlcbiAgICAubWVyZ2VNYXAoKHJlcykgPT4gT2JzZXJ2YWJsZS5mcm9tKFtcbiAgICAgICAgICAoeyB0eXBlOiBTVEFUSU9OX1NFVCwgcGF5bG9hZDogcmVzIH0pLFxuICAgICAgICAgICh7IHR5cGU6IElGQUNFX1NFVCwgcGF5bG9hZDogcmVzLmlmYWNlIH0pLFxuICAgICAgICAgICh7IHR5cGU6IFRJTUVSX1NUQVJUIH0pXSkpO1xuXG5cbi8vIEdFVF9TSUdOQUwgLT4gVXBkYXRlIGN1cnJlbnQgc2lnbmFsIGFuZCBub2Rlc1xuY29uc3QgZ2V0U2lnbmFsID0gKCBhY3Rpb24kLCB7IGdldFN0YXRlfSwgeyB3c0FQSSB9ICkgPT5cbiAgYWN0aW9uJC5vZlR5cGUoU0lHTkFMX0dFVClcbiAgICAuc3dpdGNoTWFwKCgpID0+IGdldFN0YXRpb25TaWduYWwod3NBUEksIGdldFN0YXRlKCkubWV0YS5zaWQsIGdldFN0YXRlKCkuYWxpZ24uY3VycmVudFJlYWRpbmcpKVxuICAgICAgLm1hcCggc2lnbmFsID0+ICh7IHR5cGU6IFNJR05BTF9HRVRfU1VDQ0VTUywgcGF5bG9hZDogc2lnbmFsIH0pKTtcblxuLy8gVElNRVIgTUFOQUdFUlxuY29uc3QgcnVuVGltZXIgPSAoIGFjdGlvbiQsIHsgZ2V0U3RhdGV9ICkgPT5cbiAgYWN0aW9uJC5vZlR5cGUoVElNRVJfU1RBUlQpXG4gICAgLm1lcmdlTWFwKChhY3Rpb25zKSA9PiB7XG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZS5pbnRlcnZhbChnZXRTdGF0ZSgpLm1ldGEuaW50ZXJ2YWwpXG4gICAgICAgIC50YWtlVW50aWwoYWN0aW9uJC5vZlR5cGUoVElNRVJfU1RPUCkpXG4gICAgICAgIC5tYXAoKCkgPT4gKHsgdHlwZTogU0lHTkFMX0dFVCB9KSk7XG4gICAgfSk7XG5cbmV4cG9ydCBkZWZhdWx0IHsgaWZhY2VMb2FkLCBhbGxTdGF0aW9uc0xvYWQsIGlmYWNlQ2hhbmdlLCBpbml0QWxpZ24sIGdldFNpZ25hbCwgcnVuVGltZXJ9OyJdfQ==