'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _alignApi = require('./alignApi');

var _Observable = require('rxjs/Observable');

require('rxjs/add/observable/from');

require('rxjs/add/observable/of');

require('rxjs/add/observable/interval');

require('rxjs/add/operator/takeUntil');

require('rxjs/add/operator/mergeMap');

require('rxjs/add/operator/switchMap');

require('rxjs/add/operator/mapTo');

require('rxjs/add/operator/map');

require('rxjs/add/operator/catch');

var _alignConstants = require('./alignConstants');

// LOAD INTERFACES -> Dispatch success and stations loads
var ifaceLoad = function ifaceLoad(action$, _ref, _ref2) {
  var getState = _ref.getState;
  var wsAPI = _ref2.wsAPI;
  return action$.ofType.apply(action$, [_alignConstants.IFACES_LOAD]).mergeMap(function (action) {
    return (0, _alignApi.getInterfaces)(wsAPI, getState().meta.sid);
  }).mergeMap(function (payload) {
    return _Observable.Observable.from([{ type: _alignConstants.IFACES_LOAD_SUCCESS, payload: payload }, { type: _alignConstants.STATIONS_LOAD }]);
  });
};

// LOAD ALL STATIONS -> Dispatch success and Init Align
var allStationsLoad = function allStationsLoad(action$, _ref3, _ref4) {
  var getState = _ref3.getState;
  var wsAPI = _ref4.wsAPI;
  return action$.ofType(_alignConstants.STATIONS_LOAD).mergeMap(function () {
    return (0, _alignApi.getStations)(wsAPI, getState().meta.sid);
  }).map(function (payload) {
    return { type: _alignConstants.STATIONS_LOAD_SUCCESS, payload: payload };
  }).catch(function (error) {
    return [{
      type: 'NOTIFICATION',
      payload: { msg: 'Not stations in interfaces', error: error }
    }];
  });
};

// CHANGE INTEFACE -> DIspatch get station by interface and select best signal
var ifaceChange = function ifaceChange(action$, _ref5, _ref6) {
  var getState = _ref5.getState;
  var wsAPI = _ref6.wsAPI;
  return action$.ofType(_alignConstants.IFACE_CHANGE).mergeMap(function (action) {
    return (0, _alignApi.getIfaceStation)(wsAPI, getState().meta.sid, action.payload.iface).map(function (payload) {
      return { type: _alignConstants.STATIONS_LOAD_SUCCESS, payload: payload.nodes };
    }).catch(function (error) {
      return [{
        type: 'NOTIFICATION',
        payload: { msg: 'Not stations in interface', error: error }
      }];
    });
  });
};

// INIT ALIGN -> Select best node, interface and start timer
var initAlign = function initAlign(action$, _ref7) {
  var getState = _ref7.getState;
  return action$.ofType(_alignConstants.STATIONS_LOAD_SUCCESS).map(function (action) {
    return action.payload;
  }).map(function (payload) {
    //Select most active node as default
    if (typeof getState().rx.data.most_active !== 'undefined') {
      if (payload.filter(function (x) {
        return x.mac === getState().rx.data.most_active.mac;
      }).length > 0) {
        return payload.filter(function (x) {
          return x.mac === getState().rx.data.most_active.mac;
        })[0];
      }
    }
    //Or select best node if not found most active node.
    return payload.sort(function (x, y) {
      return x.signal + y.signal;
    })[0];
  }).mergeMap(function (res) {
    return _Observable.Observable.from([{ type: _alignConstants.STATION_SET, payload: res }, { type: _alignConstants.IFACE_SET, payload: res.iface }, { type: _alignConstants.TIMER_START }]);
  });
};

// GET_SIGNAL -> Update current signal and nodes
var getSignal = function getSignal(action$, _ref8, _ref9) {
  var getState = _ref8.getState;
  var wsAPI = _ref9.wsAPI;
  return action$.ofType(_alignConstants.SIGNAL_GET).switchMap(function () {
    return (0, _alignApi.getStationSignal)(wsAPI, getState().meta.sid, getState().align.currentReading);
  }).map(function (signal) {
    return { type: _alignConstants.SIGNAL_GET_SUCCESS, payload: signal };
  });
};

// TIMER MANAGER
var runTimer = function runTimer(action$, _ref10) {
  var getState = _ref10.getState;
  return action$.ofType(_alignConstants.TIMER_START).mergeMap(function (actions) {
    return _Observable.Observable.interval(getState().meta.interval).takeUntil(action$.ofType(_alignConstants.TIMER_STOP)).map(function () {
      return { type: _alignConstants.SIGNAL_GET };
    });
  });
};

exports.default = { ifaceLoad: ifaceLoad, allStationsLoad: allStationsLoad, ifaceChange: ifaceChange, initAlign: initAlign, getSignal: getSignal, runTimer: runTimer };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hbGlnbkVwaWNzLmpzIl0sIm5hbWVzIjpbImlmYWNlTG9hZCIsImFjdGlvbiQiLCJnZXRTdGF0ZSIsIndzQVBJIiwib2ZUeXBlIiwibWVyZ2VNYXAiLCJhY3Rpb24iLCJtZXRhIiwic2lkIiwicGF5bG9hZCIsImZyb20iLCJ0eXBlIiwiYWxsU3RhdGlvbnNMb2FkIiwibWFwIiwiY2F0Y2giLCJtc2ciLCJlcnJvciIsImlmYWNlQ2hhbmdlIiwiaWZhY2UiLCJub2RlcyIsImluaXRBbGlnbiIsInJ4IiwiZGF0YSIsIm1vc3RfYWN0aXZlIiwiZmlsdGVyIiwieCIsIm1hYyIsImxlbmd0aCIsInNvcnQiLCJ5Iiwic2lnbmFsIiwicmVzIiwiZ2V0U2lnbmFsIiwic3dpdGNoTWFwIiwiYWxpZ24iLCJjdXJyZW50UmVhZGluZyIsInJ1blRpbWVyIiwiYWN0aW9ucyIsImludGVydmFsIiwidGFrZVVudGlsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFnQkE7QUFDQSxJQUFNQSxZQUFZLFNBQVpBLFNBQVksQ0FBRUMsT0FBRjtBQUFBLE1BQWFDLFFBQWIsUUFBYUEsUUFBYjtBQUFBLE1BQTJCQyxLQUEzQixTQUEyQkEsS0FBM0I7QUFBQSxTQUNoQkYsUUFBUUcsTUFBUixnQkFBa0IsNkJBQWxCLEVBQ0dDLFFBREgsQ0FDWSxVQUFDQyxNQUFEO0FBQUEsV0FBWSw2QkFBY0gsS0FBZCxFQUFxQkQsV0FBV0ssSUFBWCxDQUFnQkMsR0FBckMsQ0FBWjtBQUFBLEdBRFosRUFFS0gsUUFGTCxDQUVjLFVBQUNJLE9BQUQ7QUFBQSxXQUFhLHVCQUFXQyxJQUFYLENBQWdCLENBQ3BDLEVBQUVDLHlDQUFGLEVBQTZCRixnQkFBN0IsRUFEb0MsRUFFcEMsRUFBRUUsbUNBQUYsRUFGb0MsQ0FBaEIsQ0FBYjtBQUFBLEdBRmQsQ0FEZ0I7QUFBQSxD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Q0EsSUFBTXFCLFlBQVksU0FBWkEsU0FBWSxDQUFFL0IsT0FBRjtBQUFBLE1BQWFDLFFBQWIsU0FBYUEsUUFBYjtBQUFBLE1BQTBCQyxLQUExQixTQUEwQkEsS0FBMUI7QUFBQSxTQUNoQkYsUUFBUUcsTUFBUiw2QkFDRzZCLFNBREgsQ0FDYTtBQUFBLFdBQU0sZ0NBQWlCOUIsS0FBakIsRUFBd0JELFdBQVdLLElBQVgsQ0FBZ0JDLEdBQXhDLEVBQTZDTixXQUFXZ0MsS0FBWCxDQUFpQkMsY0FBOUQsQ0FBTjtBQUFBLEdBRGIsRUFFS3RCLEdBRkwsQ0FFVTtBQUFBLFdBQVcsRUFBRUYsd0NBQUYsRUFBNEJGLFNBQVNxQixNQUFyQyxFQUFYO0FBQUEsR0FGVixDQURnQjtBQUFBLENBQWxCOztBQUtBO0FBQ0EsSUFBTU0sV0FBVyxTQUFYQSxRQUFXLENBQUVuQyxPQUFGO0FBQUEsTUFBYUMsUUFBYixVQUFhQSxRQUFiO0FBQUEsU0FDZkQsUUFBUUcsTUFBUiw4QkFDR0MsUUFESCxDQUNZLFVBQUNnQyxPQUFELEVBQWE7QUFDckIsV0FBTyx1QkFBV0MsUUFBWCxDQUFvQnBDLFdBQVdLLElBQVgsQ0FBZ0IrQixRQUFwQyxFQUNKQyxTQURJLENBQ010QyxRQUFRRyxNQUFSLDRCQUROLEVBRUpTLEdBRkksQ0FFQTtBQUFBLGFBQU8sRUFBRUYsZ0NBQUYsRUFBUDtBQUFBLEtBRkEsQ0FBUDtBQUdELEdBTEgsQ0FEZTtBQUFBLENBQWpCOztrQkFRZSxFQUFFWCxvQkFBRixFQUFhWSxnQ0FBYixFQUE4Qkssd0JBQTlCLEVBQTJDRyxvQkFBM0MsRUFBc0RZLG9CQUF0RCxFQUFpRUksa0JBQWpFLEUiLCJmaWxlIjoiYWxpZ25FcGljcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEludGVyZmFjZXMsIGdldFN0YXRpb25zLCBnZXRJZmFjZVN0YXRpb24sIGdldFN0YXRpb25TaWduYWx9IGZyb20gJy4vYWxpZ25BcGknO1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tJztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9vZic7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvaW50ZXJ2YWwnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci90YWtlVW50aWwnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL21hcFRvJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvbWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2gnO1xuXG5pbXBvcnQge1xuICBJRkFDRVNfTE9BRCxcbiAgSUZBQ0VTX0xPQURfU1VDQ0VTUyxcbiAgSUZBQ0VfU0VULFxuICBJRkFDRV9DSEFOR0UsXG4gIFNUQVRJT05TX0xPQUQsXG4gIFNUQVRJT05TX0xPQURfU1VDQ0VTUyxcbiAgU1RBVElPTl9TRVQsXG4gIFRJTUVSX1NUQVJULFxuICBUSU1FUl9TVE9QLFxuICBTSUdOQUxfR0VULFxuICBTSUdOQUxfR0VUX1NVQ0NFU1MsXG4gIElOSVRfQUxJR05cbn0gZnJvbSAnLi9hbGlnbkNvbnN0YW50cyc7XG5cblxuLy8gTE9BRCBJTlRFUkZBQ0VTIC0+IERpc3BhdGNoIHN1Y2Nlc3MgYW5kIHN0YXRpb25zIGxvYWRzXG5jb25zdCBpZmFjZUxvYWQgPSAoIGFjdGlvbiQsIHsgZ2V0U3RhdGUgfSwgeyB3c0FQSSB9ICkgPT5cbiAgYWN0aW9uJC5vZlR5cGUoLi4uW0lGQUNFU19MT0FEXSlcbiAgICAubWVyZ2VNYXAoKGFjdGlvbikgPT4gZ2V0SW50ZXJmYWNlcyh3c0FQSSwgZ2V0U3RhdGUoKS5tZXRhLnNpZCkpXG4gICAgICAubWVyZ2VNYXAoKHBheWxvYWQpID0+IE9ic2VydmFibGUuZnJvbShbXG4gICAgICAgICh7IHR5cGU6IElGQUNFU19MT0FEX1NVQ0NFU1MsIHBheWxvYWQgfSksXG4gICAgICAgICh7IHR5cGU6IFNUQVRJT05TX0xPQUQgfSlcbiAgICAgIF0pKTtcblxuXG4vLyBMT0FEIEFMTCBTVEFUSU9OUyAtPiBEaXNwYXRjaCBzdWNjZXNzIGFuZCBJbml0IEFsaWduXG5jb25zdCBhbGxTdGF0aW9uc0xvYWQgPSAoYWN0aW9uJCwgeyBnZXRTdGF0ZSB9LCB7IHdzQVBJIH0gICkgPT5cbiAgYWN0aW9uJC5vZlR5cGUoU1RBVElPTlNfTE9BRClcbiAgICAubWVyZ2VNYXAoKCkgPT4gZ2V0U3RhdGlvbnMod3NBUEksIGdldFN0YXRlKCkubWV0YS5zaWQpKVxuICAgICAgLm1hcCgocGF5bG9hZCkgPT4gKHsgdHlwZTogU1RBVElPTlNfTE9BRF9TVUNDRVNTLCBwYXlsb2FkIH0pKVxuICAgICAgLmNhdGNoKGVycm9yID0+IChbe1xuICAgICAgICB0eXBlOiAnTk9USUZJQ0FUSU9OJyxcbiAgICAgICAgcGF5bG9hZDogeyBtc2c6ICdOb3Qgc3RhdGlvbnMgaW4gaW50ZXJmYWNlcycsIGVycm9yIH1cbiAgICAgIH1dKSk7XG5cbi8vIENIQU5HRSBJTlRFRkFDRSAtPiBESXNwYXRjaCBnZXQgc3RhdGlvbiBieSBpbnRlcmZhY2UgYW5kIHNlbGVjdCBiZXN0IHNpZ25hbFxuY29uc3QgaWZhY2VDaGFuZ2UgPSAoYWN0aW9uJCwgeyBnZXRTdGF0ZSB9LCB7IHdzQVBJIH0gKSA9PlxuICBhY3Rpb24kLm9mVHlwZShJRkFDRV9DSEFOR0UpXG4gICAgLm1lcmdlTWFwKChhY3Rpb24pID0+IGdldElmYWNlU3RhdGlvbih3c0FQSSwgZ2V0U3RhdGUoKS5tZXRhLnNpZCwgYWN0aW9uLnBheWxvYWQuaWZhY2UpXG4gICAgICAubWFwKChwYXlsb2FkKSA9PiAoeyB0eXBlOiBTVEFUSU9OU19MT0FEX1NVQ0NFU1MsIHBheWxvYWQ6IHBheWxvYWQubm9kZXMgfSkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4gKFt7XG4gICAgICAgIHR5cGU6ICdOT1RJRklDQVRJT04nLFxuICAgICAgICBwYXlsb2FkOiB7IG1zZzogJ05vdCBzdGF0aW9ucyBpbiBpbnRlcmZhY2UnLCBlcnJvciB9XG4gICAgICB9XSkpKTtcblxuLy8gSU5JVCBBTElHTiAtPiBTZWxlY3QgYmVzdCBub2RlLCBpbnRlcmZhY2UgYW5kIHN0YXJ0IHRpbWVyXG5jb25zdCBpbml0QWxpZ24gPSAoYWN0aW9uJCwgeyBnZXRTdGF0ZSB9ICkgPT5cbiAgYWN0aW9uJC5vZlR5cGUoU1RBVElPTlNfTE9BRF9TVUNDRVNTKVxuICAgIC5tYXAoYWN0aW9uID0+IGFjdGlvbi5wYXlsb2FkKVxuICAgIC5tYXAocGF5bG9hZCA9PiB7XG4gICAgICAvL1NlbGVjdCBtb3N0IGFjdGl2ZSBub2RlIGFzIGRlZmF1bHRcbiAgICAgIGlmICh0eXBlb2YgZ2V0U3RhdGUoKS5yeC5kYXRhLm1vc3RfYWN0aXZlICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIGlmIChwYXlsb2FkLmZpbHRlcih4ID0+IHgubWFjID09PSBnZXRTdGF0ZSgpLnJ4LmRhdGEubW9zdF9hY3RpdmUubWFjKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHBheWxvYWQuZmlsdGVyKHggPT4geC5tYWMgPT09IGdldFN0YXRlKCkucnguZGF0YS5tb3N0X2FjdGl2ZS5tYWMpWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL09yIHNlbGVjdCBiZXN0IG5vZGUgaWYgbm90IGZvdW5kIG1vc3QgYWN0aXZlIG5vZGUuXG4gICAgICByZXR1cm4gcGF5bG9hZC5zb3J0KCh4LCB5KSA9PiB4LnNpZ25hbCArIHkuc2lnbmFsKVswXTtcbiAgICB9KVxuICAgIC5tZXJnZU1hcCgocmVzKSA9PiBPYnNlcnZhYmxlLmZyb20oW1xuICAgICAgICAgICh7IHR5cGU6IFNUQVRJT05fU0VULCBwYXlsb2FkOiByZXMgfSksXG4gICAgICAgICAgKHsgdHlwZTogSUZBQ0VfU0VULCBwYXlsb2FkOiByZXMuaWZhY2UgfSksXG4gICAgICAgICAgKHsgdHlwZTogVElNRVJfU1RBUlQgfSldKSk7XG5cbi8vIEdFVF9TSUdOQUwgLT4gVXBkYXRlIGN1cnJlbnQgc2lnbmFsIGFuZCBub2Rlc1xuY29uc3QgZ2V0U2lnbmFsID0gKCBhY3Rpb24kLCB7IGdldFN0YXRlfSwgeyB3c0FQSSB9ICkgPT5cbiAgYWN0aW9uJC5vZlR5cGUoU0lHTkFMX0dFVClcbiAgICAuc3dpdGNoTWFwKCgpID0+IGdldFN0YXRpb25TaWduYWwod3NBUEksIGdldFN0YXRlKCkubWV0YS5zaWQsIGdldFN0YXRlKCkuYWxpZ24uY3VycmVudFJlYWRpbmcpKVxuICAgICAgLm1hcCggc2lnbmFsID0+ICh7IHR5cGU6IFNJR05BTF9HRVRfU1VDQ0VTUywgcGF5bG9hZDogc2lnbmFsIH0pKTtcblxuLy8gVElNRVIgTUFOQUdFUlxuY29uc3QgcnVuVGltZXIgPSAoIGFjdGlvbiQsIHsgZ2V0U3RhdGV9ICkgPT5cbiAgYWN0aW9uJC5vZlR5cGUoVElNRVJfU1RBUlQpXG4gICAgLm1lcmdlTWFwKChhY3Rpb25zKSA9PiB7XG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZS5pbnRlcnZhbChnZXRTdGF0ZSgpLm1ldGEuaW50ZXJ2YWwpXG4gICAgICAgIC50YWtlVW50aWwoYWN0aW9uJC5vZlR5cGUoVElNRVJfU1RPUCkpXG4gICAgICAgIC5tYXAoKCkgPT4gKHsgdHlwZTogU0lHTkFMX0dFVCB9KSk7XG4gICAgfSk7XG5cbmV4cG9ydCBkZWZhdWx0IHsgaWZhY2VMb2FkLCBhbGxTdGF0aW9uc0xvYWQsIGlmYWNlQ2hhbmdlLCBpbml0QWxpZ24sIGdldFNpZ25hbCwgcnVuVGltZXJ9OyJdfQ==